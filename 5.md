```c++
======================Solution1==========================动态规划
class Solution {
public:
    string longestPalindrome(string s) {

        int n=s.size();
        if(n<2) return s;

        vector<vector<int>> dp(n,vector<int>(n));
        int MaxSize=1;
        int begin=0;

        for(int j=1;j<n;j++){
            for(int i=0;i<j;i++){
                if(s[i]==s[j]){
                    if(j-i<3){
                        dp[i][j]=true;
                        if(j-i+1>MaxSize){
                            MaxSize=j-i+1;
                            begin=i;
                        }
                    }
                    else{
                        dp[i][j]=dp[i+1][j-1];
                        if ((j-i+1>MaxSize)&&(dp[i][j])){
                            MaxSize=j-i+1;
                            begin=i;
                        }
                    }
                }
                else dp[i][j]=false;
            }
        }
    return s.substr(begin,MaxSize);
    }
};

======================Solution2==========================中心扩展
class Solution {
public:
    string longestPalindrome(string s) {

        int n=s.size();
        if(n<2) return s;

        int begin=0;
        int MaxSize=1;

        for(int i=0;i<n-1;i++){
            auto [left1,right1]=ExpandAroundCenter(s,i,i);
            auto [left2,right2]=ExpandAroundCenter(s,i,i+1);

            if(right1-left1+1>MaxSize){
                MaxSize=right1-left1+1;
                begin=left1;
            } 
            if(right2-left2+1>MaxSize){
                MaxSize=right2-left2+1;
                begin=left2;
            } 
        }
        return s.substr(begin,MaxSize);
    }

    pair<int,int> ExpandAroundCenter(string s, int left, int right){
        while(left>=0&&right<=s.size()&&s[left]==s[right]){
            left--;
            right++;
        }
        return {left+1,right-1};
    }
};
```